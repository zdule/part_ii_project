\centerline{\Large Computer Science Tripos -- Part II -- Project Proposal}
\vspace{6mm}
\centerline{\Large Optimizing tracing instrumentation inside the Linux kernel}
\vspace{6mm}
\centerline{\large D. Živanović, Trinity College}
\vspace{4mm}
\centerline{\large Originator: Dr Lucian Carata and Dr Ripduman Sohan}
\vspace{4mm}
\centerline{\large \today}

\vspace{8mm}

\noindent
{\bf Project Supervisor:} Dr Lucian Carata
\vspace{2mm}

\noindent
{\bf Director of Studies:} Prof Frank Stajano, Dr Sean Holden
\vspace{2mm}
 
\noindent
{\bf Project Overseers:} Dr Sean Holden, Dr Andreas Vlachos

%\vspace{4mm}

% Main document

% note function calls vs function call sites
\section*{Introduction}

    Dynamic tracing is an irreplaceable tool for analysing and debugging production systems. Tracing can be added to a 
    program without recompiling it or even restarting it. It has no overhead when disabled and adding a tracing
    probe changes only a few bytes of the program's instructions.
    By instrumenting the operating system's functions we can easily gain insight into how programs interact 
    with each other and use resources.

    %However, to be used in production the tracing mechanism must only minimally impact the performance of the 
    %traced program. Unfortunately this isn't the case with kprobes 

    Filtering out events, and summarizing them with a statistic can greatly reduce the amount of recorded data
    while tracing. In the Linux kernel this is done by specifying a user-supplied program to process function call events. 
    To guarantee safety and responsiveness this program is written in a restricted, non-Turing-complete 
    Instruction Set Architecture called eBPF. eBPF programs are guaranteed to halt in a limited number of steps,
    and to only perform valid memory accesses.

    The kprobes mechanism of the Linux kernel implements tracing by replacing the first byte of the 
    traced function with a software interrupt instruction whose handler does a hash table lookup on the 
    previous value of the instruction pointer to determine which callback function to call.
    This leads to some limitations, namely:

    \vspace{-0.60em}
    \begin{itemize}
        \setlength{\itemsep}{-0.3em}
        \item Poor scaling with the number of traced functions. This is due to the hash table used being limited in size.
        \item Inability to attach probes to specific call sites of a function, instead of function itself. 
        This is important when we want to trace calls to a function from a specific part of the kernel,
        and tracing all calls just to discard most of the data is prohibitively inefficient
    \end{itemize}

    Kamprobes, which are a probing mechanism developed by the Computer Lab's Digital Technology group, can instrument 
    specific call sites, but they don't support attaching eBPF programs as callbacks.

    The goal of this project is to enhance the tracing capabilities of the Linux kernel by allowing attaching eBPF programs
    to multiple call sites of a function in a low-overhead way. The plan is to do this by modifying the implementation of
    kamprobes and the Linux kernel to make it possible to register eBPF programs as kamprobes callbacks.
    I expect this enhancement to greatly reduce overhead of using eBPF with many probes, and when only some call sites
    should be traced.

    Furthermore I will be comparing the overhead of using eBPF programs with kamprobes and with kprobes. 
    Finally I will demonstrate the usefulness of eBPF and kamprobes by measuring some aspect of the Linux kernels
    performance.
 
\section*{Starting Point}

    This project will use the kamprobes kernel module as a dependency.
    The kamprobes module allows attaching callbacks functions to call instructions.
    Is currently does not have any interface accessible from the user space, and does not support
    attaching eBPF programs as callbacks.
    At some point extending the kamprobes module itself will likely prove convenient or necessary.

    The project will also depend on the Linux kernel, importantly, to run eBPF programs.
    I might need to modify parts of the kernel.

    %Since kamprobes is an open source project, this will be done in terms of an open source contribution.
    %In any case only the diff of the contribution will be considered as my contribution.

    I have previously written a basic, example Linux kernel module to familiarise myself with developing for the 
    Linux kernel. None of the code from that module will be used. 

\section*{Work to be done}

    The work to be done can be split into the following parts:

    \begin{itemize}
        \item Investigating how kprobes run eBPF programs, especially how the function arguments and the 
        current call stack is passed to the eBPF program.
       
        \item Getting familiar with the kamprobes project. Writing a simple callback function that logs 
        function arguments and attaching it to a call site in the kernel.

        \item Using the knowledge gained in the previous two steps to write the kamprobe callback that runs
        the eBPF program. In the most optimistic case this could be completely done inside a kernel module,
        but it may turn out that modifying the kernel source code is needed.

        \item Developing a user-space library for attaching an eBPF program to a kamprobe. This will involve 
        choosing a suitable user space to kernel interface (ioctl, device files, sys filesystem),
        and implementing the kernel module and library functionality.

        \item Developing test programs that shows that executing the traced call instruction results in calling the 
        eBPF program, and that the program can access the function arguments

        %\item Developing a test that ensures that executing the traced call instruction results in calling the 
        %eBPF program with the correct function arguments and call stack, that the function call is then executed
        %with the arguments and stack being unchanged, and that the instruction after the traced call is executed.

        %\item Developing a test that ensures that the implementation is thread safe, namely that concurrent requests
        %are handled correctly, and that probes firing concurrently don't cause any problems.

        \item Comparing the performance hit that an application suffers when kernel functions are traced with kprobes
        and with kamprobes. For example, the application can be nginx, and the performance hit can be measured
        in decrease of throughput and increase in latency. The measurements should show how performance changes when
        more probes are added.

        \item Demonstrating the usefulness of the implementation by measuring something about the kernel, for example
        the amount of time threads are blocked on some function.
    \end{itemize}

\section*{Resources required}

    I will do the project on my personal laptop (i5-8250U 1.60GHz quad-core CPU, 8GB of RAM, 256GB SSD, Ubuntu 18.04 LTS).
    
    For backup, all files will regularly be pushed to Github. Additionally, I will backup to an external hard disk
    once per week.

    Testing kernel modules, testing custom kernel builds if needed, and measuring performance will be done on 
    a Computer Lab owned server provided by my supervisor. To access the server {\bf I will need a Computer Lab account}.

\section*{Success criteria}

    This project is to be considered successful if:
    \begin{itemize}
        \item The kernel and user-space library code to instrument a function call with an eBPF program are implemented.
        Test programs demonstrating that function call arguments can be accessed by the eBPF program work.

        \item The usefulness of the project is demonstrated by measuring something about the kernel using 
        kamprobes and eBPF programs.

        \item The performance hit that an application suffers when instrumented with kprobes and kamprobes is 
        compared.

    \end{itemize}

\section*{Possible extensions}

    Possible extension to the project include:
    \begin{itemize}
        \item Adding a user friendly way to specify which call sites to instrument. Perhaps by specifying a
        source function, filename or module in which the function call is made, and the called function.

        \item Performing micro-architectural evaluation of the probing mechanisms using the performance counters
        provided by the CPU. These include counters of executed instructions, memory accesses, cache misses, and others.
        
        \item Adding specialised data structures to eBPF. The only memory eBPF programs can use that persists after an
        eBPF program has exited are eBPF maps. An eBPF map has one of a dozen possible types which are variations
        on arrays and hash maps. This extension deals with adding a more specialised eBPF maps to improve performance
        of eBPF tracing programs.
    \end{itemize}

\section*{Timetable, milestones and deadlines}

    Planned starting date is 24/10/2019. The work is split into 10 work packages:
    \begin{enumerate}

        \item {\bf Michaelmas weeks 3-4 (24/10/2019 - 6/11/2019)} 

            {\bf Deadline 25/10/2019:} Submission of the project proposal (this document) 

            Familiarise myself with the kamprobes kernel module. Compile and run the module.
            Attach a simple callback to a call site.

            Examine the kernel implementation of kprobes.

            Milestones: I know how to compile and use the kamprobes module.
            I know how kprobes run eBPF programs and how they pass function arguments and the call stack to the program.
        
        \item {\bf Michaelmas weeks 5-6 (07/11/2019 - 20/11/2019)} 

            Decide how to implement a kamprobes callback that runs eBPF programs.

            Start implementing the callback.

            Milestones: An implementation plan is made, and implementation has begun.

        \item {\bf Michaelmas weeks 7-8 (21/11/2019 - 04/12/2019)}

            Finish the callback implementation.

            Milestones: An eBPF program can be attached to a call site from a kernel module.

        \item {\bf Michaelmas vacation (05/12/2019 - 15/01/2020)}
        
            Implement the user-space library.
            Use the user-space library to write test programs.
            
            Write the introduction and preparation chapters of the dissertation.
            Send these chapters to the supervisor for review.

            Milestones: An eBPF program can be attached to a call site from user space.
            There is an automated test showing that the code works.
            A draft of implementation and preparation chapters is completed and sent for review.

        \item {\bf Lent weeks 1-2 (16/01/2020 - 29/01/2020)} 

            Implement performance tests.

            Prepare the progress report and presentation. Rehearse the presentation.

            Milestones: I have collected the performance data.
            The progress report and presentation are finished and the presentation is rehearsed.

        \item {\bf Lent weeks 3-4 (30/01/2020 - 12/02/2020)} 

            {\bf Deadline 31/01/2020:} Submission of the progress report 
            
            Choose a thing in the kernel to measure using kamprobes and eBPF,
            and write the eBPF programs that measure them.

            Milestones: The eBPF programs are written, and the metrics are measured using kamprobes.

        \item {\bf Lent weeks 5-6 (13/02/2020 - 26/02/2020)} 

            Either implement extensions or complete delayed work.

            Milestones: Work on extensions has begun.

        \item {\bf Lent weeks 7-8 (27/02/2020 - 11/03/2020)}

            Either implement extensions or complete delayed work.
            
            Begin working on implementation, and evaluation chapters.

            Milestones: All coding and evaluation including extensions has been completed. An early draft
            of the implementation and evaluation chapters is completed.

        \item {\bf Lent Vacation (12/03/2020 - 22/04/2020)}

            Finish the implementation, evaluation and conclusion chapters of the dissertation.

            {\bf Deadline 12/04/2020:} Send the first draft to my supervisor

            Incorporate feedback from my supervisor.

            {\bf Deadline 22/04/2020:} Send the final draft to my supervisor

            Milestones: The dissertation is complete and has already gone through one revision.

        \item {\bf Easter week 1(23/04/2020 - 29/04/2020)} 

            Polish the dissertation. Incorporate feedback from my supervisor.

            {\bf Deadline 01/05/2020:} Goal date for dissertation submission

            Milestones: The dissertation is submitted and the project is over.

    \end{enumerate}
    {\bf Deadline 08/05/2020:} Submission of the final dissertation
