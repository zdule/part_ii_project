\centerline{\Large Computer Science Tripos \textendash{} Part II \textendash{} Project Proposal}
\vspace{6mm}
\centerline{\Large Optimizing tracing instrumentation inside the Linux kernel}
\vspace{6mm}
\centerline{\large D. Živanović, Trinity College}
\vspace{4mm}
\centerline{\large Originators: Dr Lucian Carata and Dr Ripduman Sohan}
\vspace{4mm}
\centerline{\large \today}

\vspace{8mm}

\noindent
{\bf Project Supervisor:} Dr Lucian Carata
\vspace{2mm}

\noindent
{\bf Director of Studies:} Prof Frank Stajano, Dr Sean Holden
\vspace{2mm}
 
\noindent
{\bf Project Overseers:} Dr Sean Holden, Dr Andreas Vlachos

\newcommand{\kamprobe}[1]{\texttt{#1}}

%\vspace{4mm}

% Main document
\section*{Introduction}

    Dynamic tracing is an irreplaceable tool for analysing and debugging production systems. 
    Some reasons tracing is so useful are that tracing has no overhead 
    when disabled and that it can be added to a program without recompiling it or even restarting it. 
    Furthermore, by instrumenting the kernel of an operating system we can easily gain insight into
    the workings of any program running on the machine.

    To be used in production a tracing mechanism mustn't significantly impact the performance of the 
    traced program. Unfortunately, tracing in the Linux kernel can scale poorly when increasing the number of active probes.
    The goal of this project is to enable low-overhead tracing with many active probes for the purpose of
    understanding the system's behavior in detail.

    As a first step towards enhancing the tracing in Linux we should examine the mechanisms and capabilities
    which are currently provided, namely eBPF programs and kprobes.

    The job of an eBPF program is to process the traced events as they occur.
    eBPF programs are important because preprocessing the measurement data before it is recorded to 
    memory can drastically reduce the tracing overhead. 
    For example if we are only interested in an average of some measurements it is much better to keep 
    a running average using eBPF while collecting the data, than to record all the data about events and 
    then process it later.

    eBPF programs are often one-off programs run inside the kernel and written to diagnose an urgent problem. 
    As such there is a risk that an erroneous program could crash the kernel or make it unresponsive.
    To ensure this never happens, eBPF programs are written in a restricted non-Turing-complete 
    Instruction Set Architecture and run by a virtual machine inside the kernel.

    One of the tracing mechanisms with which eBPF programs can be used is kprobes. 
    Kprobes implement tracing by replacing the first byte of the traced function with a software interrupt 
    instruction whose handler does a hash table lookup on the 
    previous value of the instruction pointer to determine which callback function to invoke.
    This leads to some limitations, namely:

    \vspace{-0.60em}
    \begin{itemize}
        \setlength{\itemsep}{-0.3em}
        \item Poor scaling with increasing the number of active probes. This is because the hash table used is limited in size.
        \item Inability to attach probes to specific call sites of a function, instead of the function itself. 
        This is important when we want to trace calls to a function from a specific part of the kernel,
        and tracing all calls just to discard most of the data is prohibitively inefficient.
    \end{itemize}

    Kamprobes, which are an alternative probing mechanism developed by the Computer Lab's Digital Technology group, 
    can instrument specific call sites and scale better with increasing the number of active probes, 
    but they don't support using eBPF programs as callbacks, and have limitations in how function arguments
    are accessed. Additionally, kamprobes don't have an interface to the user space, 
    and require the user to know the kernel space addresses of call sites to be traced,
    which is information not readily available outside the kernel.

    This project aims to enhance the tracing capabilities of the Linux kernel by allowing attaching eBPF programs
    to multiple call sites of a function in a scalable, low-overhead way. 
    The plan is to do this by modifying the implementation of
    kamprobes and the Linux kernel to make it possible to register eBPF programs as kamprobes callbacks.
    I expect this enhancement to greatly reduce the overhead of using eBPF when there are many active probes,
    or when only some call sites should be traced.

    Furthermore, I will compare the overhead of using eBPF programs with kamprobes and with kprobes. 
    Finally, I will demonstrate the usefulness of eBPF and kamprobes by measuring detailed information 
    about waiting in a subsystem of the Linux kernel.
 
\section*{Starting Point}

    This project will use the kamprobes kernel module as a dependency.
    The kamprobes module allows the attachemnt of callback functions to call instructions.
    It currently does not have any interface accessible from the user space, and does not support
    attaching eBPF programs as callbacks.
    At some point extending the kamprobes module itself is likely to prove convenient or necessary.

    The project will also depend on the Linux kernel, importantly, to run eBPF programs.
    I might need to make very small changes to parts of the kernel.

    %Since kamprobes is an open source project, this will be done in terms of an open source contribution.
    %In any case only the diff of the contribution will be considered as my contribution.

    I have previously written a basic, example Linux kernel module to familiarise myself with developing for the 
    Linux kernel. None of the code from that module will be used. 

\section*{Work to be done}

    The work to be done can be split into the following parts:

    \begin{itemize}
        \item Investigating how eBPF programs run on top of kamprobes, especially how the program
        accesses the function arguments and the current call stack.
       
        \item Getting familiar with the kamprobes project. Writing a simple callback function that logs 
        function arguments and attaching it to a call site in the kernel.

        \item Using the knowledge gained in the previous two steps to write the kamprobe callback that runs
        an eBPF program. This work part will involve writing the kernel module, and possibly a few simple
        changes to the kernel source code.
        %In the most optimistic case this could be completely done inside a kernel module,
        %but it may turn out that small modification of the kernel source code is needed.

        \item Developing a user space library for attaching eBPF programs to kamprobes. This will involve 
        choosing a suitable user space to kernel interface (ioctl, device files, the sys filesystem),
        and implementing the kernel module and library functionality. % /* Note, write about testing the correctness */ 

        \item Developing test programs that show that executing the traced call instruction results in calling the 
        eBPF program, and that the program can access the function arguments.

        %\item Developing a test that ensures that executing the traced call instruction results in calling the 
        %eBPF program with the correct function arguments and call stack, that the function call is then executed
        %with the arguments and stack being unchanged, and that the instruction after the traced call is executed.

        %\item Developing a test that ensures that the implementation is thread safe, namely that concurrent requests
        %are handled correctly, and that probes firing concurrently don't cause any problems.

        \item Comparing the performance hit that an application suffers when kernel functions are traced with kprobes
        and with kamprobes. 
        For example, I could measure the decrease in throughput and increase in latency that nginx web server suffers
        when parts of the kernel's network stack are traced.
        Measurements should also be done varying the number of active probes to show differences in scaling
        between kprobes and kamprobes.

        \item Demonstrating the usefulness of the implementation by measuring data related to waiting in a subsystem
        of the kernel.
    \end{itemize}


\section*{Success criteria}

    This project should be considered successful if:
    \begin{itemize}
        \item The kernel module and user space library code to instrument a function call with an eBPF program are implemented, and
        test programs demonstrating that function call arguments can be accessed by the eBPF program work.

        \item The usefulness of the project is demonstrated by measuring detailed information about waiting in 
        a kernel subsystem using kamprobes and eBPF programs.

        \item The performance hit that an application suffers when instrumented with kprobes and kamprobes is 
        measured and compared.

    \end{itemize}

\section*{Possible extensions}

    Possible extension to the project include:
    \begin{itemize}
        \item Adding a user friendly way of specifying which call sites to instrument. Perhaps by specifying a
        source function, filename or module in which the function call is made, and the called function.

        \item Performing micro-architectural evaluation of the probing mechanisms using the performance counters
        provided by the CPU. These include counters of executed instructions, memory accesses, cache misses, and others.
        
        \item Adding specialised data structures to eBPF. The only memory eBPF programs can use that persists after an
        eBPF program has exited are eBPF maps. An eBPF map has one of a dozen possible types which are variations
        on arrays and hash maps. This extension deals with adding more specialised eBPF maps to improve performance
        of eBPF tracing programs.
    \end{itemize}

\section*{Timetable, milestones and deadlines}

    Planned starting date is 24/10/2019. The work is split into the following 10 work packages:
    \begin{enumerate}

        \item {\bf Michaelmas weeks 3-4 (24/10/2019 - 6/11/2019)} 

            {\bf Deadline 25/10/2019:} Submission of the project proposal (this document) 

            Familiarise myself with the kamprobes kernel module. Compile and run the module.
            Attach a simple callback to a call site.

            Examine the kernel implementation of kprobes.

            Milestones: I know how to compile and use the kamprobes module.
            I know how kprobes run eBPF programs and how they pass function arguments and the call stack to the program.
        
        \item {\bf Michaelmas weeks 5-6 (07/11/2019 - 20/11/2019)} 

            Decide how to implement a kamprobes callback that runs eBPF programs.

            Start implementing the callback.
            If needed, implement simple modifications of the Linux kernel which are needed today
            get the callback working. 
            
            I expect the required changes to the Linux kernel to be small and simple to write, 
            but in case that I encounter any unexpected complications, two of the later work packages have been 
            allocated to completeting delayed work or doing some of the extensions. In this case, I will
            be forced to do fewer or no extensions.

            Milestones: An implementation plan is made, and implementation has begun.

        \item {\bf Michaelmas weeks 7-8 (21/11/2019 - 04/12/2019)}

            Finish the callback implementation.

            Milestones: An eBPF program can be attached to a call site from a kernel module.

        \item {\bf Michaelmas vacation (05/12/2019 - 15/01/2020)}
        
            Implement the user space library.
            Use the user space library to write test programs.
            
            Write the introduction and preparation chapters of the dissertation.
            Send these chapters to the supervisor for review.

            Milestones: An eBPF program can be attached to a call site from user space.
            There is an automated test showing that the code works.
            A draft of introduction and preparation chapters is completed and sent for review.

        \item {\bf Lent weeks 1-2 (16/01/2020 - 29/01/2020)} 

            Implement performance tests.

            Prepare the progress report and presentation. Rehearse the presentation.

            Milestones: I have collected the performance data.
            The progress report and presentation are finished and the presentation is rehearsed.

        \item {\bf Lent weeks 3-4 (30/01/2020 - 12/02/2020)} 

            {\bf Deadline 31/01/2020:} Submission of the progress report 
            
            Measure metrics about waiting inside a module of the Linux kernel using kamprobes and eBPF.

            Milestones: The eBPF programs are written, and the metrics are measured using kamprobes.

        \item {\bf Lent weeks 5-6 (13/02/2020 - 26/02/2020)} 

            Either implement extensions or complete delayed work.

            Milestones: Work on extensions has begun.

        \item {\bf Lent weeks 7-8 (27/02/2020 - 11/03/2020)}

            Either implement extensions or complete delayed work.
            
            Begin writing the implementation and evaluation chapters.

            Milestones: All coding and evaluation, including work on any extensions, has been completed. An early draft
            of the implementation and evaluation chapters is completed.

        \item {\bf Lent Vacation (12/03/2020 - 22/04/2020)}

            Finish the implementation, evaluation and conclusion chapters of the dissertation.

            {\bf Deadline 12/04/2020:} Send the first draft to my supervisor

            Incorporate feedback from my supervisor.

            {\bf Deadline 22/04/2020:} Send the final draft to my supervisor

            Milestones: The dissertation is complete and has already gone through one revision.

        \item {\bf Easter week 1(23/04/2020 - 29/04/2020)} 

            Polish the dissertation. Incorporate feedback from my supervisor.

            {\bf Deadline 01/05/2020:} Goal date for dissertation submission

            Milestones: The dissertation is submitted and the project is over.

    \end{enumerate}
    {\bf Deadline 08/05/2020:} Submission of the final dissertation

\section*{Resources required}

    I will do the project on my personal laptop (i5-8250U 1.60GHz quad-core CPU, 8GB of RAM, 256GB SSD, Ubuntu 18.04 LTS).
    
    For backup, all files will regularly be pushed to Github. Additionally, I will backup to an external hard disk
    once per week.

    Testing kernel modules, testing custom kernel builds if needed, and measuring performance will be done on 
    a Computer Lab owned server provided by my supervisor. To access the server {\bf I will need a Computer Lab account}.

    Given that I will have a server to test my code on, I will be able to continue working from MCS computers if my laptop fails.
