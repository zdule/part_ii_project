31.10.2019: set up git repo and backups to hd

01.11.2019: 
- installed llvm (v6), as suggested in linux/samples/bpf
- created a pilot module that runs ebpf program. 
	- challanges: 
		- can I run two probes at once, how can I know
		- do I need to disable interrupts
		- which function runs the eBPF program, there is no documentation
		- how to do reference counting
		

02.01.2020: Workload plan
- Return probes:
	- access to arguments and stack pointer at the time of return (like the return instruction is instrumented)

- Testing
	- Unit test of the module itself? (is the module loaded, are device files there)
	- Entry probes
		- Gets called at all
		- Correct instrumentation:
			- call stack
			- c arguments (all registers + 2 on stack)
			- sp and ip registers are correct
			- registers set by assembly? The idea would be to be independent of the c calling convention when testing
			
		- No unwanted side-effects:
			- traced function gets executed, and can access registers
		
	- Return probes testing:
		- Gets called at all
		- Correct implementation:
			- probes get correct registers from the end of the function
			  most noteably the return value and call stack
			
		- No unwanted side-effects:
			- the return occurs and the callee can't tell the probe executed... 
		
	- Race conditions:
		- Multiple executions of the traced function
		- Multiple calls while a probe is added
		- Multiple calls while a probe is removed (?)
		
	- Other
		- Multiple probes for same function (good to know if it works)
		
- bpftool? 
	- would be good not to rely on bcc and dlls
	
- C Library
	- add fds? best that way.. 
	
	
04.01.2020: Mapping from ubuntu kernel names to mainline tags
https://people.canonical.com/~kernel/info/kernel-version-map.html
Source of my kernel sans the ubuntu patches https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/?h=linux-4.15.y
4.15.0-72.81 -> 4.15.18


io_uring
- 3 syscalls
- io_uring_setup to create the uring
	- it creates a kernel thread to process requests in io_sq_offload_start
	- the entry point for the kernel thread is io_sq_thread
	- this thread should also be woken up via a wait by the entry syscall
	- io_sq_thread calls io_submit_sqes which calls io_submit_sqe which calls io_queue_sqe, then __io_queue_sqe, which finally 
	  adds io_sq_wq_submit_work to the workqueue
	- io_sq_wq_submit_work
	- io_sq_wq_submit_work -> __io_submit_sqe -> io_read or io_write -> calls operation from fops on the file, eg. read_iter 
	- finally io_rw_done call wich triggers completion on kiocb
	- kiocb complete will call io_complete_rw
	- this calls io_cqring_add_event which adds event to the completion queue

void synchronize_rcu_tasks ( void);
to free dynamic trampolines buffers :)
https://www.youtube.com/watch?v=93uE_kWWQjs
