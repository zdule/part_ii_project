% The master copy of this demo dissertation is held on my filespace
% on the cl file serve (/homes/mr/teaching/demodissert/)

% Last updated by MR on 2 August 2001

\documentclass[12pt,twoside,notitlepage]{report}

\usepackage{a4}
\usepackage{verbatim}
%\usepackage{navigator}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor={black},
    filecolor={black},
    linkcolor={black},
    urlcolor={black}
}

%\input{epsf}                            % to allow postscript inclusions
% On thor and CUS read top of file:
%     /opt/TeX/lib/texmf/tex/dvips/epsf.sty
% On CL machines read:
%     /usr/lib/tex/macros/dvips/epsf.tex



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\addtolength{\oddsidemargin}{6mm}       % adjust margins
\addtolength{\evensidemargin}{-8mm}

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable
\usepackage{biblatex}
\addbibresource{refs.bib}
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\hfill{\LARGE \bf Dušan Živanović}

\vspace*{60mm}
\begin{center}
\Huge
{\bf Optimizing tracing instrumentation inside the Linux kernel} \\
\vspace*{5mm}
Computer Science Tripos -- Part II \\
\vspace*{5mm}
Tirinty College \\
\vspace*{5mm}
2020
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\setcounter{page}{1}
\pagenumbering{roman}
\pagestyle{plain}

\chapter*{Acknowledgements}
\chapter*{Declaration}
    I, Dušan Živanović of Trinity College, being a candidate for Part II of the Computer Science Tripos, hereby declare that this dissertation and the work described in it are my own work, unaided except as may be specified below, and that the dissertation does not contain material that has already been used to any substantial extent for a comparable purpose. 

    I, Dušan Živanović of Trinity College, am content for my dissertation to be made available to the students and staff of the University. 

    Signed 

    Date 

    \bigskip
    \leftline{Signed [signature]}

    \medskip
    \leftline{Date [date]}


\chapter*{Proforma}


{\large
\begin{tabular}{ll}
Candidate Number:   & \bf TBD                   \\
Project Title:      & \bf Optimizing tracing instrumentation \\
                    & \bf inside the Linux kernel \\
Examination:        & \bf Computer Science Tripos -- Part II, 2020      \\
Word Count:         & \bf TBD \\
Line Count:         & \bf TBD \\
Project Originator: & Dr Lucian Carata and Dr Ripduman Sohan     \\
Supervisor:         & Dr Lucian Carata                  \\ 
\end{tabular}
}


\section*{Original Aims of the Project}


\section*{Work Completed}


\section*{Special Difficulties}



\tableofcontents

\listoffigures

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\cleardoublepage        % just to make sure before the page numbering
                        % is changed

\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{headings}

\chapter{Introduction}
    This dissertation introduces kambpf, a flexible, low-overhead function-call tracing system for the Linux kernel. Compared to the tracing capabilities currently in the Linux kernel, kambpf has a lower overhead and the added flexibility instrumenting any subset of call sites of a given function (and add massive amounts of probes). Compared to the kamprobes project on which it builds upon, kambpf provides the flexibility of being programmable with eBPF, and an interface from the user space. 

    The kambpf system is available as a loadable kernel module with its functionality exported to the user space via a simple to use C library.

    \section{Motivation}

        Dynamic tracing is a way to gain insight into the execution of a program. It is done by inserting additional instructions into to binary of a process at runtime to record data, such as values of function arguments, stack traces or timing. The effect is similar to inserting printf's into the source code, but it can be enabled and disabled at runtime without recompiling or even stoping the program, and with no cost when tracing is disabled.

        Dynamic tracing is especially useful for examining long running processes in production. In such a scenario, restrating the process would be too disruptive. On the other hand replicating the conditions in a test environment might be impossible due to a unique combination of hardware, configuration, other applications running concurrently, and the workload. 

        Useful questions that dynamic tracing can answer are which part of the code, or which external resource is the bottleneck; what values is this function usually called with; why does a piece of code exibit pathological behaviour; how much resources is dedicated to running this process. With answers to these questions we can fix performance problems, optimize the code, choose which resource to buy more of.

        It is particularly convenient to instrument the operating system kernel because it is the meeting point of all processes and the hardware resources. For example, just by instrumenting kernel functions are called we can record when processes are scheduled, how much data they send and to whom, and the latency and throughput a hard drive.

        An assumption present in the implementation available in the Linux kernel (TODO: too indirect) is that the user will want to instrument a few specific function calls related to the issue they are debugging. For this reason the implementation hasn't been designed to support large numbers of probes. A use case that requires large number of probes is measuring how much time is spend executing functions in each file. To achieve this probes would be added to all function calls made from any file into other files. This requires massive number of probes, and is something that current implementations struggle with as they scale poorly with the number of probes used.

        When analysing performance by tracing it is most important that the overhead is as small as possible otherwise our measurements might show that the tracing itself is the bottleneck, or in other way show a result skewed by tracing. As is often the case the easiest way to reduce the cost of tracing is simply to do less of it, which mostly refers to saving less data about events into buffers. This is usually done in two ways. Firstly, if a data point is going to be discarded, then it should be discarded as soon as possible, before writing it to a buffer. Secondly, if we are only interested in a summary of the collected data, such as an average, then the tracing instrumentation should maintain a average while tracing instead of recording all data to a buffer and processing it afterwards. Because the rules for which events should be discarded and how the collected data should be summarized vary between different use cases the tracing system should allow specifying the action taken in response to events.

		Even more overhead can be avoided if the tracing code doesn't even run when no data should be collected. Lets imagine that we to analyse the high memory usage of a device driver. To do so we might want to see where in the code is most memory allocated, and we can collect this data by tracing the function \texttt{kmalloc}. As we are only interested in allocations coming from that particular driver, the handler that we specify to run in response to \texttt{kmalloc} being called will check to see if the function is called from our driver and only if it is will collect the stack trace and the size of memory allocated. For all of the much more common calls to kmalloc happening from outside the driver this whole process will have been unnecessary overhead. This overhead can be eliminated by tracing the just the individual function call instructions of kmalloc that we are interested in, instead of the kmalloc function itself. The practical difference is that the tracing code is dynamically inserted into multiple call sites calling kmalloc instead of inserting the instrumentation at the beginning of the kmalloc function itself. Although this does more work upfront, there is no cost for the calls originating outside of our driver. Because we can better describe what events we are interested in by specifying the individual call sites of a function, tracing has less overhead.

		Finally, specifying the actions to be taken in response to events, the event handlers, should be simple and safe, preferably not requiring custom kernel modules, in which any mistake could crash the kernel. A new addition to the Linux kernel, the eBPF virtual machine, provides a safe way to run user supplied programs. The tracing systems in the Linux kernel all support adding eBPF programs as event handlers, but none of them support call site probes efficiently.

		The goal of this project is thus to create a flexible and efficient tracing system for the Linux kernel, that can trace individual call sites, and can take eBPF programs as event handlers. Furthermore I will measure the overhead of this new tracing mechanism, and compare it to the overhead of the existing solutions. Finally, in order to verify that the tracing system can be used for a real world application I will use it to analyse where the kernel is spending time and waiting when sending a TCP packet. (TBC)


    \section{Previous work}
		\begin{itemize}
			\item \texttt{ftrace} is a Linux kernel function tracer. It can be used to trace any function in the Linux kernel and can take eBPF programs as event handlers. It does not support tracing individual call instructions

			\item \texttt{kprobe}s are another tracing mechanism of the Linux kernel and like \texttt{ftrace} it also support eBPF. Additionally it can instrument any instruction. Unfortunately, tracing call instructions is done by inserting breakpoint instructions, which is inefficient. \texttt{kprobe}s also scale poorly with the number of probes is high, which is the case when call instructions are individually instrumented.

			\item \texttt{kamprobes} a low-overhead tracing mechanism that supports tracing many call instructions. The main limitation of this probing mechanism is that event handlers must be functions in the Linux kernel, so a user that needs custom filtering and aggregation needs to write a loadable kernel module. Furthermore, \texttt{kamprobes} have been developed as a part of the \texttt{resourceful} project and currently don't provide an interface outside of the Linux kernel.
		\end{itemize}

	\section{Summary}

		This chapter introduced dynamic tracing, the need for low-overhead probes, filtering and aggregating events in event handlers. Additionally it demonstrated why instrumenting function call instructions is more flexible than instrumenting functions themselves. Finally the goal of the dissertation was stated as developing a flexible and efficient system for tracing in the Linux kernel, and the Previous work section described why current solutions are unsatisfactory.

		Mention that the plain is to add eBPF support to kamprobes in the introduction?

\input{chapters/preparation.tex}
\chapter{implementation}

    \section{Repository overview}

\printbibliography

\chapter*{Project Proposal}

%\input{propbody}

\end{document}
