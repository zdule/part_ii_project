\chapter{Preparation}
 
\section {Requirements analysis} 
    The main goal of the project was to make new uses of tracing possible with scalable support of large numbers of probes. The design I find should be efficient and reasonably simple to deploy and use. These ideas are expanded into requirements listed bellow. The requirements explain decisions made during the implementation.

    \begin{itemize}
        \item \textbf{Scalable support for large numbers of probes} -- This is the reason other people should care about the project. It makes more information about the system accessible.
        \item \textbf{Precise specification of which function calls to trace} -- The intent is to keep overhead low by tracing only the function calls we need to trace.
        \item \textbf{Performance and flexibility of custom event handler} -- Custom event handlers can be used to avoid recording all information regarding a function call. Instead event handlers can process and record only the needed information.
        \item \textbf{Use without writing kernel code} -- Writing kernel code is time consuming and error-prone. Therefore, not requiring custom kernel code to add probes and for event handlers will make my design a lot easier to use.
        \item \textbf{Support for x86-64}-- The scope of the design is limited to the x86-64 Architecture because it is the most common architecture for servers. Additionally, the code will architecture specific so supporting multiple architectures requires a lot of additional work.
    \end{itemize}
    
    The project idea described in the proposal is to satisfy these requirements by building on the existing implementation for scalable, low-overhead instruction call probes, called kamprobes, and use the eBPF virtual machine to specify event handlers. Listed bellow is the work that needed to be done to satisfy the requirements.

    \begin{itemize}
        \item Build a kernel module that implement a scalable interface for adding and removing probes from user space. The kernel module also needed to implement kamprobes event handlers that call eBPF programs.
        \item Build a user space library for interfacing with the kernel module.
    \end{itemize}

    As part of ensuring that the implementation is correct and usable, and evaluating the project I committed to:
    \begin{itemize}
        \item Build end-to-end test that demonstrate the implementation is working as intended.
        \item Write a demo application using my implementation of tracing to measure queue latency in io\_uring, an asynchronous IO system of the Linux kernel.
        \item Compare the performance of my implementation to existing implementations in the Linux kernel.
    \end{itemize}

\section{Background} 
    The following section will describe material I needed to understand before beginning work on the project.

    \subsection{Instrumenting function calls - kamprobes}
        Since I relied on kamprobes for function call tracing, and I had to modify their implementation, I needed to learn how kamprobes work. C function calls are implemented using the call machine code instruction. Kamprobes change the program machine code while its running to change its behaviour, in particular to record the execution of a call instruction.

        A call instruction only has a single argument -- the address of the function being called, also known as the call destination. The x86-64 machine code representation of a call instruction would consist of a single byte operation code, and the 4 byte offset to the destination address (that is by how much we need to jump forwards, or backwards to get to the function address).

        If we want to trace a particular call to a function `foo(int a, int b)` we can do it by writing a new function, called for example trace\_foo(int a, int b), which stores the argument a and b into a buffer, calls the original function foo(a,b) and returns. We would then replace the 4 bytes of the function call argument to store the offset to trace\_foo instead of foo. When the call instruction is executed, trace\_foo is called instead of foo, and the function arguments are recorded. Because trace\_foo itself calls foo, apart from the arguments being recorded the effect of the call is the same.

        This is in principle how kamprobes work. Function trace\_foo is the event handler of the call instruction is executed event. Note that in the scheme I just described the event handler has to call the original function itself. Apart from being poor design because the handler might not call the original instruction, this design is problematic because you cannot simply use the same handler for multiple different functions. So what kamprobes really do is write machine code to memory that calls the handler and then the original function. They use the address of this generated machine code as the target of the traced call instruction.

    \subsection{Loadable kernel modules}
        The Linux kernel supports loading code that   

    \subsection{The eBPF virtual machine}
        System administrators often configure behaviour of the operating system. Examples of this are specifying which packets to filter, security policies, and also tracing event handlers. 

        Instead of adding more and more configuration options to define precise policies, the Linux kernel developers added a virtual machine, called eBPF, to the kernel. In this way policies can be configured in the form of programs for the eBPF virtual machine. Benefits of this approach are that eBPF programs are guaranteed to terminate as they are statically verifiend not to contain any loops. Further more eBPF programs may not write to kernel memory and the read they make are checked at runtime to be safe.

        A eBPF program is developed in C and compiled by the llvm compiler into bytecode. The bytecode is loaded into the kernel with the \texttt{bpf} systemcall. As a result of loading the program the user gets a file descriptor which they can use as a handle for any subsequent operations with the program. One such operation is attaching it to a probe.

    \subsection{The x86-64 calling convention}


\section{Choice of tools and languages}


\section{Development strategy}

\section{Starting point}

\section{Open source licensing}

\section{Summary}
